// ====================================================================
// 04_AGGREGATOR.GS - CORRIGIDO
// Agregação que recebe dados já processados (SEM ler aba Geral)
// ====================================================================

const Aggregator = {
  
//STATUS_VALIDOS: ['Faturado', 'Pagamento aprovado', 'Entregue', 'Em transporte'],
//STATUS_EXCLUIDOS: ['Cancelado', 'Pagamento não aprovado'],

// Função helper para validar status
isStatusValido: function(status) {
  return true; // ✅ Processar todos os status
},

  /**
   * Processa dados já agregados do DataProcessor
   * - modoAditivo=false: Remove dados antigos e insere novos (reprocessamento completo)
   * - modoAditivo=true: SOMA aos dados existentes (processamento incremental dia-a-dia)
   */
  processarDadosAgregados: function(abaDestino, dadosAgregados, modoAditivo = false) {
    if (!dadosAgregados || dadosAgregados.length === 0) {
      Logger.registrar('AVISO', '', '', 'Nenhum dado agregado para processar', {});
      return;
    }
    
    Logger.registrar('INFO', '', '', 
      `Processando ${dadosAgregados.length} registros agregados para aba ${abaDestino} (modo: ${modoAditivo ? 'ADITIVO' : 'SUBSTITUICAO'})`, {});
    
    const sheet = SheetManager.obterOuCriarAbaEmpresa(abaDestino);
    
    if (modoAditivo) {
      // ✅ MODO ADITIVO: Carrega dados existentes e SOMA aos novos
      const dadosExistentes = this.carregarDadosExistentesComValores(sheet);
      
      dadosAgregados.forEach(novoRegistro => {
        const chave = `${novoRegistro.data}_${novoRegistro.alias}`;
        
        if (dadosExistentes.has(chave)) {
          // Linha já existe - SOMAR valores
          const registroExistente = dadosExistentes.get(chave);
          const linhaSheet = registroExistente.linha;
          
          const novaReceita = registroExistente.receita + novoRegistro.receitaVendas;
          const novoDesconto = registroExistente.desconto + novoRegistro.descontosConcedidos;
          const novoJuros = registroExistente.juros + novoRegistro.jurosVendas;
          
          sheet.getRange(linhaSheet, 4, 1, 3).setValues([[
            novaReceita,
            novoDesconto,
            novoJuros
          ]]);
          
          Logger.registrar('INFO', '', '', 
            `Valores SOMADOS para ${chave}`, 
            { receita_antes: registroExistente.receita, receita_depois: novaReceita });
        } else {
          // Linha não existe - INSERIR nova
          const ultimaLinha = sheet.getLastRow();
          sheet.getRange(ultimaLinha + 1, 1, 1, 6).setValues([[
            novoRegistro.data,
            novoRegistro.nomeEmpresa,
            novoRegistro.alias,
            novoRegistro.receitaVendas,
            novoRegistro.descontosConcedidos,
            novoRegistro.jurosVendas
          ]]);
        }
      });
      
    } else {
      // ✅ MODO SUBSTITUIÇÃO: Remove dados antigos e insere novos (comportamento original)
      const periodosParaLimpar = new Set();
      dadosAgregados.forEach(linha => {
        const chave = `${linha.data}_${linha.alias}`;
        periodosParaLimpar.add(chave);
      });
      
      const linhasRemovidas = this.limparPeriodos(sheet, periodosParaLimpar);
      if (linhasRemovidas > 0) {
        Logger.registrar('INFO', '', '', 
          `Linhas removidas do período: ${linhasRemovidas}`, {});
      }
      
      dadosAgregados.forEach(linha => {
        const ultimaLinha = sheet.getLastRow();
        sheet.getRange(ultimaLinha + 1, 1, 1, 6).setValues([[
          linha.data,
          linha.nomeEmpresa,
          linha.alias,
          linha.receitaVendas,
          linha.descontosConcedidos,
          linha.jurosVendas
        ]]);
      });
    }
    
    this.formatarAbaEmpresa(sheet);
    
    Logger.registrar('SUCESSO', '', '', 
      `Dados agregados processados para aba ${abaDestino}`, 
      { registros_processados: dadosAgregados.length });
  },
  
  /**
   * Remove linhas da planilha que correspondem aos períodos sendo reprocessados
   */
  limparPeriodos: function(sheet, periodosParaLimpar) {
    const dados = sheet.getDataRange().getValues();
    const linhasParaRemover = [];
    
    // Identificar linhas a remover (de baixo para cima para não quebrar índices)
    for (let i = dados.length - 1; i >= 1; i--) {
      const data = dados[i][0];
      const alias = dados[i][2];
      
      if (data && alias) {
        const dataFormatada = Utilitarios.formatarData(new Date(data));
        const chave = `${dataFormatada}_${alias}`;
        
        if (periodosParaLimpar.has(chave)) {
          linhasParaRemover.push(i + 1); // +1 porque array é 0-based, sheet é 1-based
        }
      }
    }
    
    // Remover linhas (de baixo para cima)
    linhasParaRemover.forEach(linha => {
      sheet.deleteRow(linha);
    });
    
    return linhasParaRemover.length;
  },
  
  /**
   * Agrega dados mensais para todas as abas destino (MANTIDA para compatibilidade)
   */
  agregarDadosMensais: function() {
    Logger.registrar('INFO', '', '', 'Iniciando agregação mensal', {});
    
    // NOTA: Esta função agora é chamada indiretamente pelo DataProcessor
    // Mantida para compatibilidade com triggers existentes
    
    Logger.registrar('SUCESSO', '', '', 'Agregação mensal concluída via DataProcessor', {});
  },
  
  /**
   * Carrega dados existentes da aba empresa COM VALORES (para modo aditivo)
   */
  carregarDadosExistentesComValores: function(sheet) {
    const dados = sheet.getDataRange().getValues();
    const map = new Map();
    
    for (let i = 1; i < dados.length; i++) {
      const data = dados[i][0];
      const alias = dados[i][2];
      const receita = parseFloat(dados[i][3]) || 0;
      const desconto = parseFloat(dados[i][4]) || 0;
      const juros = parseFloat(dados[i][5]) || 0;
      
      if (data && alias) {
        const dataFormatada = Utilitarios.formatarData(new Date(data));
        const chave = `${dataFormatada}_${alias}`;
        map.set(chave, { 
          linha: i + 1,
          receita: receita,
          desconto: desconto,
          juros: juros
        });
      }
    }
    
    return map;
  },
  
  /**
   * Carrega dados existentes da aba empresa (mantida para compatibilidade)
   */
  carregarDadosExistentes: function(sheet) {
    const dados = sheet.getDataRange().getValues();
    const map = new Map();
    
    for (let i = 1; i < dados.length; i++) {
      const data = dados[i][0];
      const alias = dados[i][2];
      
      if (data && alias) {
        const dataFormatada = Utilitarios.formatarData(new Date(data));
        const chave = `${dataFormatada}_${alias}`;
        map.set(chave, { linha: i + 1 });
      }
    }
    
    return map;
  },
  
  /**
   * Formata aba da empresa (ordenação e formatação)
   */
  formatarAbaEmpresa: function(sheet) {
    const ultimaLinha = sheet.getLastRow();
    if (ultimaLinha > 1) {
      // Ordenar por data (mais recente primeiro) e depois por alias
      const range = sheet.getRange(2, 1, ultimaLinha - 1, 6);
      range.sort([{column: 1, ascending: false}, {column: 3, ascending: true}]);
      
      // Formatação de moeda nas colunas de valores
      sheet.getRange(2, 4, ultimaLinha - 1, 3)
        .setNumberFormat('R$ #,##0.00');
    }
  },
  
  /**
 * Processa dados de pesquisa na aba Pesquisa - COM ORDENAÇÃO CRONOLÓGICA
 */
processarDadosPesquisa: function(dadosTransformados) {
  const sheet = SheetManager.obterAbaPesquisa();
  
  // Limpar dados existentes (manter apenas header)
  const ultimaLinha = sheet.getLastRow();
  if (ultimaLinha > 1) {
    sheet.deleteRows(2, ultimaLinha - 1);
  }
  
  if (dadosTransformados.length === 0) {
    return;
  }
  
  // ✅ ORDENAR por Data Criação (índice 4) ANTES de inserir
  dadosTransformados.sort((a, b) => {
    const dataA = new Date(a[4]); // Coluna "Data Criação"
    const dataB = new Date(b[4]);
    return dataA - dataB; // Ordem crescente (mais antigo primeiro)
  });
  
  // Adicionar novos dados ordenados
  const range = sheet.getRange(2, 1, dadosTransformados.length, dadosTransformados[0].length);
  range.setValues(dadosTransformados);
  
  // Formatação
  sheet.getRange(2, 8, dadosTransformados.length, 5)
    .setNumberFormat('R$ #,##0.00');
  
  Logger.registrar('SUCESSO', '', '', 
    'Dados de pesquisa processados na aba Pesquisa (ordenados cronologicamente)', 
    { registros: dadosTransformados.length });
},

/**
 * Atualizar aba de estoque de uma empresa
 */
atualizarEstoqueEmpresa: function(nomeEmpresa, alias) {
  try {
    const sheetEstoque = SheetManager.obterAbaEstoque(nomeEmpresa);
    
    // Buscar todas as empresas para pegar os pedidos da empresa específica
    const empresas = ConfigManager.lerConfiguracao();
    const config = empresas.find(e => e.alias === alias);
    
    if (!config) {
      Logger.registrar('ERRO', nomeEmpresa, alias, 'Empresa não encontrada', {});
      return;
    }
    
    // Buscar todos os pedidos da empresa (último ano)
    const hoje = new Date();
    const umAnoAtras = new Date(hoje.getFullYear() - 1, hoje.getMonth(), 1);
    const dataInicio = Utilitarios.formatarData(umAnoAtras);
    const dataFim = Utilitarios.formatarData(hoje);
    
    const pedidos = YampiAPI.buscarPedidosPorPeriodo(
      config.alias, 
      config.token, 
      config.secretKey, 
      dataInicio, 
      dataFim
    );
    
    const dadosAgregados = this.agregarEstoquePorSKU(pedidos, nomeEmpresa, alias);
    
    // Limpar aba (manter header)
    const ultimaLinha = sheetEstoque.getLastRow();
    if (ultimaLinha > 1) {
      sheetEstoque.deleteRows(2, ultimaLinha - 1);
    }
    
    // Escrever dados agregados
    if (dadosAgregados.length > 0) {
      const linhas = dadosAgregados.map(d => [
        d.mesAno,
        d.nomeProduto,
        d.sku,
        d.quantidadeVendida,
        d.receitaTotalSKU
      ]);
      
      sheetEstoque.getRange(2, 1, linhas.length, 5).setValues(linhas);
    }
    
    Logger.registrar('SUCESSO', nomeEmpresa, alias, 
      `Estoque atualizado: ${dadosAgregados.length} SKUs`, {});
    
  } catch (erro) {
    Logger.registrar('ERRO', nomeEmpresa, alias, 
      'Erro ao atualizar estoque', { erro: erro.toString() });
  }
},

};